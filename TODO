0) work out how to make it testable

1) update/write the docs

3) track connections so we can stop when we're finished
- the Session should know when all Connections die; the Agent should
  know when Sessions are finished
- there should also be a timeout somewhere in case a request gets stuck.
  timeout behaviour is not well-defined anyway

4) test that the response is what we expect. 

The original XML doesn't log body contents, so we can't compare
against body text, just headers.

A default test might be to compare http status, content-type, document
title - should be sufficient to detect real brokenness

There needs to be a sane way to override that

5) There is a limit on the number of timers available
set_max_timers(ct).  

"Sets the maximum number of timers and periodic timers that may be
outstanding at any given time. You only need to call set_max_timers if
you need more than the default number of timers, which on most
platforms is 1000. Call this method before calling EventMachine#run."

 /* Allow a user to increase the maximum number of outstanding timers.
  * If this gets "too high" (a metric that is of course platform dependent),
  * bad things will happen like performance problems and possible overuse
  * of memory.
  * The actual timer mechanism is very efficient so it's hard to know what
  * the practical max, but 100,000 shouldn't be too problematical.
  */

We are using C_H (default 2) connections per host per session.
Between requests each connection requires a single timer.  So if we
are hitting a single host our timer use is basically 2x the number of
sessions.  If 1000 is a bottleneck before CPU becomes an issue,
100,000 probably won't be, but we should know how many we're going to
need and raise the limit if we need to

6) I rather suspect our response parsing is dog-slow, and for load
tests we should replace it with something simpler.  Note that http
headers are all US-ASCII - we don't need to worry about utf-8 or anything

8) Will there ever be a need to add new events on the fly or do we
always know the full set of requests before EM.run is called?  Perhaps
we want to sustain load for ten or twenty minutes to eliminate "ramp
up" effects on a server: do our data structures allow that?


9) if the original session asked for gzip content-encoding and the
server provided it, we should probably do the same (and do).  However
it would be good to provide tools for anyone testing body content to
know that the *correct* gzipped content had been delivered